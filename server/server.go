package main

import (
	"bufio"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/pions/webrtc"
	"github.com/pions/webrtc/examples/util"
	"github.com/pions/webrtc/pkg/datachannel"
	"github.com/pions/webrtc/pkg/ice"
	"golang.org/x/net/websocket"
)

//Debug levels
const (
	None = iota
	Info
	Dump
	Spew
)

//DEBUGLEVEL represents the amount of debug output that will be generated by the server
const DEBUGLEVEL = Spew

//Global state of all the lobbies in the server
var lobbies []Lobby

//A mutex to prevent threading mayhem on lobbies
var lobbyMutex = &sync.Mutex{}

func debugPrintln(debugLevel int, a ...interface{}) {
	if DEBUGLEVEL >= debugLevel {
		fmt.Print("[" + time.Now().Format("15:04:05") + "] ")
		fmt.Println(a...)
	}
}

//Song is the server-side representation of a song used to manage the songs uploaded to the lobby
type Song struct {
	audio  *os.File
	title  string
	artist string
	tag1   string
	tag2   string
}

//Client is the server-side view of a THING client used to manage connections and permissions
type Client struct {
	control       net.Conn                  //Defines the control channel
	rtcconn       *webrtc.RTCPeerConnection //Defines the webRTC connection used for managing data channel
	channel       *webrtc.RTCDataChannel    //Defines the webrtc data channel used for file transfer
	username      string
	moderator     bool
	notifications []string
	delay         time.Time
}

//Lobby is the server-side representation of a collection of clients and songs
type Lobby struct {
	name          string
	admin         Client
	users         []Client
	songQueue     []Song
	newUsers      chan Client //Clients yet to be buffered
	bufferedUsers []Client    //Clients buffered until accepted
	userAccept    chan Client //Clients yet to be accepted
}

//Promotes a user to moderator
func (lobby *Lobby) promoteUser(user Client) {
	for i := 0; i < len(lobby.users); i++ {
		if lobby.users[i].username == user.username {
			debugPrintln(Dump, "Promoting: "+lobby.users[i].username+" to moderator")
			lobby.users[i].moderator = true
		}
	}
}

//Adds song to the lobbies queue
func (lobby *Lobby) addSongToQueue(song Song) {
	debugPrintln(Dump, "adding "+song.title+" to song queue")
	lobby.songQueue = append(lobby.songQueue, song)
}

//Returns all the clients in a particular lobby, excluding the buffered clients
func (lobby *Lobby) getClients() []Client {
	var clients []Client
	clients = append(clients, lobby.admin)
	for _, client := range lobby.users {
		clients = append(clients, client)
	}
	return clients
}

/*
func (client *Client) updateDelayTime() {
	t1 := time.Now()
	//TODO: Ping Client

	t2 := time.Now()
	diff := t2.Sub(t1)
	client.delay = diff
}

func (lobby *Lobby) pushSong(song Song) string {
	lobby.fileSend(song)
}

func (lobby *Lobby) syncPlay(song Song) string {

}

func (lobby *Lobby) syncPause() string {

}

func (lobby *Lobby) sendNotifications() {

}
*/
/*
TODO: Remove this
func (lobby *Lobby) msgSend(msg string) {
	clients := lobby.getClients()
	for _, client := range clients {
		debugPrintln(Dump, "Sending "+msg+" to client "+client.username)
		client.channel.Send(datachannel.PayloadString{Data: []byte(msg)})
	}
}
*/

//Used to send song data to all connected clients over a WebRTC data channel
func (lobby *Lobby) fileSend(song Song) {
	clients := lobby.getClients()
	fileStat, _ := song.audio.Stat()
	var fileData = make([]byte, fileStat.Size())
	song.audio.Read(fileData)
	for _, client := range clients {
		debugPrintln(Dump, "Sending file to client "+client.username)
		//Tell client a transfer is starting
		fmt.Fprintf(client.control, "SEND "+song.title+" "+song.artist+" "+song.tag1+" "+song.tag2+"\n")
		//Transfer in >=1000 byte chunks because of the limits of WebRTC
		for i := 0; i < len(fileData); i += 1000 {
			if (i + 1000) > len(fileData) { //The last set of bytes in the file
				err := client.channel.Send(datachannel.PayloadBinary{Data: fileData[i:]})
				if err != nil {
					panic(err)
				}
			} else {
				err := client.channel.Send(datachannel.PayloadBinary{Data: fileData[i : i+1000]})
				time.Sleep(time.Microsecond * 50) //May need to be higher on slower networks
				if err != nil {
					panic(err)
				}
			}
		}
		//Tell client end of transmision
		fmt.Fprintf(client.control, "OKAY\n")
	}
}

//Creates a Client and handles WebRTC magic
func createClient(config webrtc.RTCConfiguration, userName string, conn net.Conn, mod bool) Client {
	if mod {
		debugPrintln(Spew, "Creating client "+userName+" with mod status true")
	} else {
		debugPrintln(Spew, "Creating client "+userName+" with mod status false")
	}
	//Handle webRTC stuff
	pconn, err := webrtc.New(config)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create new connection\n")
		panic(err)
	}

	//Create the data channel
	dataChannel, err := pconn.CreateDataChannel("audio", nil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create data channel\n")
		panic(err)
	}

	//Set some handlers...
	dataChannel.OnOpen(func() { debugPrintln(Dump, "Data Channel opened to "+userName) })
	pconn.OnICEConnectionStateChange(func(connState ice.ConnectionState) {
		debugPrintln(Dump, userName+" "+connState.String())
	})

	//Exchange peering offers
	debugPrintln(Spew, "Exchanging offers")
	offer, err := pconn.CreateOffer(nil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create offer\n")
		panic(err)
	}
	fmt.Fprintf(conn, util.Encode(offer.Sdp)+"\n")
	nin := bufio.NewScanner(bufio.NewReader(conn))
	nin.Split(bufio.ScanLines)
	nin.Scan()
	sd := util.Decode(nin.Text())

	answer := webrtc.RTCSessionDescription{
		Type: webrtc.RTCSdpTypeAnswer,
		Sdp:  sd,
	}
	err = pconn.SetRemoteDescription(answer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to set remote descriptor\n")
		panic(err)
	}
	//Construct client with everything
	return Client{username: userName, control: conn, rtcconn: pconn, channel: dataChannel, moderator: mod}
}

//Handles all operations within the lobby
func (lobby *Lobby) lobbyHandler() {
	for {
		// lobby.sendNotifications() TODO: Impliment function and uncomment
		select {
		//If a client wants to connect
		case newUser := <-lobby.newUsers:
			lobby.bufferedUsers = append(lobby.bufferedUsers, newUser)
			clients := lobby.getClients()
			debugPrintln(Dump, "Sending join notifications")
			//Send join notifications to the admin client and all moderator clients
			for i := 0; i < len(clients); i++ {
				if clients[i].moderator { //Admin is also a moderator
					debugPrintln(Spew, "sending join notification "+newUser.username+" to "+clients[i].username)
					clients[i].notifications = append(clients[i].notifications, "User "+newUser.username+" wants to join "+lobby.name)
				}
			}
		//If a client is pending acception
		case accept := <-lobby.userAccept:
			debugPrintln(Dump, accept.username+" Joinging "+lobby.name)
			lobby.users = append(lobby.users, accept)
		//Handle all client commands
		default:
			clients := lobby.getClients()
			for i := 0; i < len(clients); i++ {
				buffer := make([]byte, 8192)
				n, err := clients[i].control.Read(buffer)
				if err == io.EOF {
					debugPrintln(Info, clients[i].username+" disconnected")
					if clients[i].username == lobby.admin.username { //Destroy lobby and disconnect everyone
						debugPrintln(Info, "Admin disconnected, destroying lobby "+lobby.name)
						for j := 0; j < len(clients); j++ {
							clients[j].control.Close()
							clients[i].rtcconn.Close()
						}
						for j := 0; j < len(lobby.bufferedUsers); j++ {
							lobby.bufferedUsers[j].control.Close()
							lobby.bufferedUsers[j].rtcconn.Close()
						}
						//Ideally deallocate lobby, TODO: find better way to invalidate it
						lobby.name = ""
						lobby.admin = Client{}
						lobby.users = nil
						lobby.bufferedUsers = nil
						return
					}
				}
				if err != nil {
					debugPrintln(Spew, err)
					continue
				}
				if n == 0 {
					continue
				}
				//If we get here there are no network errors
				sin := bufio.NewScanner(strings.NewReader(string(buffer)))
				sin.Split(bufio.ScanWords)
				//Something was read, handle connection in a non blocking way
				if lobby.admin.username == clients[i].username { //If send from admin
					//If accepting users move them from bufferedUsers to userAccept channel
					sin.Scan()
					switch sin.Text() {
					case "ACCEPT":
						sin.Scan()
						user := sin.Text()
						for j := 0; j < len(lobby.bufferedUsers); i++ {
							if lobby.bufferedUsers[j].username == user {
								lobby.userAccept <- lobby.bufferedUsers[j]
								//Remove Client from buffer
								lobby.bufferedUsers = append(lobby.bufferedUsers[:j], lobby.bufferedUsers[j+1:]...)
								fmt.Fprintf(clients[i].control, "OKAY\n")
								break
							}
						}
					case "PLAY":
					case "PAUSE":
					case "SONG":
					case "SEND":
					default:
					}
				} else if clients[i].moderator { //If sent from a moderator
					//If accepting users move them from bufferedUsers to userAccept channel
					sin.Scan()
					if sin.Text() == "ACCEPT" {
						sin.Scan()
						user := sin.Text()
						for j := 0; j < len(lobby.bufferedUsers); i++ {
							if lobby.bufferedUsers[j].username == user {
								lobby.userAccept <- lobby.bufferedUsers[j]
								//Remove Client from buffer
								lobby.bufferedUsers = append(lobby.bufferedUsers[:j], lobby.bufferedUsers[j+1:]...)
								fmt.Fprintf(clients[i].control, "OKAY\n")
								break
							}
						}
					}
				} else { //Sent by user

				}
			}
		}
	}
}

//Web socket handler called by the HTTP server
func THINGServer(cconn *websocket.Conn) {
	fmt.Fprintf(os.Stderr, "THING client connecting...\n")
	lobbyMutex.Lock()
	config := webrtc.RTCConfiguration{
		IceServers: []webrtc.RTCIceServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	debugPrintln(Info, "Accepting control connection...")
	nin := bufio.NewScanner(bufio.NewReader(cconn))
	nin.Split(bufio.ScanWords)

	for nin.Scan() {
		switch nin.Text() {
		case "LOBBY":
			for _, lobby := range lobbies {
				fmt.Fprintf(cconn, lobby.name+"\n")
			}
			fmt.Fprintf(cconn, "OKAY\n")
		case "JOIN":
			nin.Scan()
			lobbyName := nin.Text()
			nin.Scan()
			username := nin.Text()
			//Check if username is taken
			for i := 0; i < len(lobbies); i++ {
				clients := lobbies[i].getClients()
				for j := 0; j < len(clients); j++ {
					if clients[j].username == username {
						fmt.Fprintf(cconn, username+" TAKEN\n")
						continue
					}
				}
			}
			//Check if lobby exists and add user to it
			for i := 0; i < len(lobbies); i++ {
				if lobbies[i].name == lobbyName {
					fmt.Fprintf(cconn, "OKAY\n")
					select {
					case lobbies[i].newUsers <- createClient(config, username, cconn, false):
					default:
						fmt.Println("Channel Full, rejecting user")
					}
					fmt.Fprintf(cconn, "OKAY\n")
					lobbyMutex.Unlock()
					return
				}
			}
		case "CREATE":
			//If the lobby doesn't exist, create it and spawn handler
			nin.Scan()
			lobbyName := nin.Text()
			nin.Scan()
			username := nin.Text()
			for _, lobby := range lobbies {
				if lobby.name == lobbyName {
					fmt.Fprintf(cconn, lobbyName+" TAKEN\n")
					continue
				}
			}
			fmt.Fprintf(cconn, "OKAY\n")
			newChan := make(chan Client, 25)
			acceptChan := make(chan Client, 25)
			newLobby := Lobby{name: lobbyName, admin: createClient(config, username, cconn, true), newUsers: newChan, userAccept: acceptChan}
			lobbies = append(lobbies, newLobby)
			fmt.Fprintf(cconn, "OKAY\n")
			go lobbies[len(lobbies)-1].lobbyHandler()
			lobbyMutex.Unlock()
		default:
		}
	}

}

func main() {
	//Start HTTP server and send client to browser
	http.Handle("/", http.FileServer(http.Dir("../client/")))
	//Start the web socket handler
	http.Handle("/socket", websocket.Handler(THINGServer))
	debugPrintln(Info, "Starting HTTP and WS server")

	//Initialization stuff
	webrtc.RegisterDefaultCodecs()

	//Start server
	http.ListenAndServe(":80", nil)
}
